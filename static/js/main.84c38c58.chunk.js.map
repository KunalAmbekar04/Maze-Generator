{"version":3,"sources":["Component/Navbar/Navbar.js","Component/Cell/Cell.js","Component/Grid/Grid.js","App.js","serviceWorker.js","index.js"],"names":["Navbar","className","Component","Cell","id","this","props","current","stack","flag","Grid","state","generateBtn","resetBtn","solveBtn","cellArr","arr","visited","n","size","createGrid","i","j","push","key","breakWall","cell1","cell2","x","Number","y","a","document","getElementById","b","style","borderLeft","borderRight","borderTop","borderBottom","getFormerNeighbour","cell","neighbours","top","String","right","bottom","left","indexOf","length","Math","floor","random","generateMaze","clearInterval","idInterval1","setInterval","generateMazeUtil","source","currentDOM","next","setState","parent","querySelectorAll","classList","remove","add","pop","getActualNeighbour","currentCell","solveMaze","destination","idInterval","idInterval2","solveMazeUtil","grid","idInterval3","pathVisualisation","backgroundColor","path","resetMaze","cells","Array","fill","width","onClick","disabled","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.84c38c58.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport \"./Navbar.css\";\n\nclass Navbar extends Component {\n  render() {\n    return (\n      <div className=\"nav\">\n        <h1>Maze Generator</h1>\n      </div>\n    );\n  }\n}\n\nexport default Navbar;\n","import React, { Component } from \"react\";\nimport \"./Cell.css\";\n\nclass Cell extends Component {\n  render() {\n    return <div className=\"cell\" id={this.props.id}></div>;\n  }\n}\n\nexport default Cell;\n","import React, { Component } from \"react\";\nimport Cell from \"../Cell/Cell\";\nimport \"./Grid.css\";\n\nlet current = \"\"; // hold current cell value.\nlet stack = []; // for Backtracing purpose.\nlet flag = true; // for checking first time implementation.\n\nclass Grid extends Component {\n  // to enable and disable buttons\n  state = {\n    generateBtn: true,\n    resetBtn: false,\n    solveBtn: false,\n  };\n\n  cellArr = []; // hold all the cell component. (DOM)\n  arr = []; // hold id of all cell component. (string)\n  visited = []; // keep track of visited cell.\n  n = this.props.size; // size of grid = n x n\n\n  // initialize cellAr and arr.\n  createGrid = () => {\n    for (let i = 0; i < this.n; i++) {\n      for (let j = 0; j < this.n; j++) {\n        this.cellArr.push(<Cell id={`(${i},${j})`} key={`(${i},${j})`} />);\n        this.arr.push(`(${i},${j})`);\n      }\n    }\n  };\n\n  // break wall between two cell.\n  breakWall = (cell1, cell2) => {\n    let x = Number(cell1[1]) - Number(cell2[1]);\n    let y = Number(cell1[3]) - Number(cell2[3]);\n    let a = document.getElementById(cell1);\n    let b = document.getElementById(cell2);\n\n    // Here we make common border color similar to background color.\n    if (y === 1) {\n      a.style.borderLeft = \"1px solid white\";\n      b.style.borderRight = \"1px solid white\";\n    } else if (y === -1) {\n      a.style.borderRight = \"1px solid white\";\n      b.style.borderLeft = \"1px solid white\";\n    }\n\n    if (x === 1) {\n      a.style.borderTop = \"1px solid white\";\n      b.style.borderBottom = \"1px solid white\";\n    } else if (x === -1) {\n      a.style.borderBottom = \"1px solid white\";\n      b.style.borderTop = \"1px solid white\";\n    }\n  };\n\n  // return a random non visited neighbour of current cell.\n  getFormerNeighbour = (cell) => {\n    let neighbours = [];\n    let top = \"(\" + String(Number(cell[1]) - 1) + \",\" + cell[3] + \")\";\n    let right = \"(\" + cell[1] + \",\" + String(Number(cell[3]) + 1) + \")\";\n    let bottom = \"(\" + String(Number(cell[1]) + 1) + \",\" + cell[3] + \")\";\n    let left = \"(\" + cell[1] + \",\" + String(Number(cell[3]) - 1) + \")\";\n\n    if (this.arr.indexOf(top) >= 0) {\n      if (!this.visited[this.arr.indexOf(top)]) {\n        neighbours.push(top);\n      }\n    }\n\n    if (this.arr.indexOf(right) >= 0) {\n      if (!this.visited[this.arr.indexOf(right)]) {\n        neighbours.push(right);\n      }\n    }\n\n    if (this.arr.indexOf(bottom) >= 0) {\n      if (!this.visited[this.arr.indexOf(bottom)]) {\n        neighbours.push(bottom);\n      }\n    }\n\n    if (this.arr.indexOf(left) >= 0) {\n      if (!this.visited[this.arr.indexOf(left)]) {\n        neighbours.push(left);\n      }\n    }\n\n    if (neighbours.length > 0) {\n      return neighbours[Math.floor(Math.random() * neighbours.length)];\n    }\n    return null;\n  };\n\n  // for maze generation\n  generateMaze = () => {\n    clearInterval(this.idInterval1);\n    let source = \"(0,0)\";\n    // generateMazeUtil function has to be execute in loop between after specific interval.\n    this.idInterval1 = setInterval(() => this.generateMazeUtil(source), 50);\n  };\n\n  generateMazeUtil = (source) => {\n    // for termination of setInterval in generateMaze.\n    if (!flag) {\n      if (stack.length === 0) {\n        this.setState({\n          generateBtn: false,\n          resetBtn: true,\n          solveBtn: true,\n        });\n        clearInterval(this.idInterval1);\n      }\n    }\n\n    let currentDOM;\n    let next; // hold neighbour of current cell.\n    let parent = document.querySelectorAll(\".cell\");\n    for (let i = 0; i < parent.length; i++) {\n      parent[i].classList.remove(\"active\");\n    }\n\n    // execute for first time only.\n    if (flag) {\n      current = source;\n    }\n\n    // mark current cell as visited.\n    // get its non visited neighbour and also mark it as visited.\n    // push current cell in stack and break wall b/w current and next cell.\n    // if there is no non visited neighbour left then backtrack to recently added cell to stack.\n    currentDOM = document.getElementById(current);\n    currentDOM.classList.add(\"active\");\n    currentDOM.classList.add(\"visited\");\n    this.visited[this.arr.indexOf(current)] = true;\n    next = this.getFormerNeighbour(current);\n    flag = false;\n    if (next) {\n      this.visited[this.arr.indexOf(next)] = true;\n      stack.push(current);\n      this.breakWall(current, next);\n      current = next;\n    } else if (stack.length > 0) {\n      current = stack.pop(); // backtrack mechanism.\n    }\n  };\n\n  //  return a random non visited neighbour of current cell where there exist no wall between them. \n  getActualNeighbour = (cell) => {\n    let neighbours = [];\n    let top = \"(\" + String(Number(cell[1]) - 1) + \",\" + cell[3] + \")\";\n    let right = \"(\" + cell[1] + \",\" + String(Number(cell[3]) + 1) + \")\";\n    let bottom = \"(\" + String(Number(cell[1]) + 1) + \",\" + cell[3] + \")\";\n    let left = \"(\" + cell[1] + \",\" + String(Number(cell[3]) - 1) + \")\";\n    let currentCell = document.getElementById(cell);\n    \n    // Here we check if wall exist or not.\n    if (this.arr.indexOf(top) >= 0) {\n      if (!this.visited[this.arr.indexOf(top)]) {\n        let topCell = document.getElementById(top);\n        if (\n          topCell.style.borderBottom === \"1px solid white\" &&\n          currentCell.style.borderTop === \"1px solid white\"\n        ) {\n          neighbours.push(top);\n        }\n      }\n    }\n\n    if (this.arr.indexOf(right) >= 0) {\n      if (!this.visited[this.arr.indexOf(right)]) {\n        let rightCell = document.getElementById(right);\n        if (\n          rightCell.style.borderLeft === \"1px solid white\" &&\n          currentCell.style.borderRight === \"1px solid white\"\n        ) {\n          neighbours.push(right);\n        }\n      }\n    }\n\n    if (this.arr.indexOf(bottom) >= 0) {\n      if (!this.visited[this.arr.indexOf(bottom)]) {\n        let bottomCell = document.getElementById(bottom);\n        if (\n          bottomCell.style.borderTop === \"1px solid white\" &&\n          currentCell.style.borderBottom === \"1px solid white\"\n        ) {\n          neighbours.push(bottom);\n        }\n      }\n    }\n\n    if (this.arr.indexOf(left) >= 0) {\n      if (!this.visited[this.arr.indexOf(left)]) {\n        let leftCell = document.getElementById(left);\n        if (\n          leftCell.style.borderRight === \"1px solid white\" &&\n          currentCell.style.borderLeft === \"1px solid white\"\n        ) {\n          neighbours.push(left);\n        }\n      }\n    }\n\n    if (neighbours.length > 0) {\n      return neighbours[Math.floor(Math.random() * neighbours.length)];\n    }\n    return null;\n  };\n\n  // for solving maze.\n  solveMaze = () => {\n    let source = \"(0,0)\";\n    let destination = \"(\" + (this.n - 1) + \",\" + (this.n - 1) + \")\";\n    clearInterval(this.idInterval);\n    this.visited = [];\n    stack = [];\n    flag = true;\n    // solveMazeUtil function has to be execute in loop between after specific interval.\n    this.idInterval2 = setInterval(\n      () => this.solveMazeUtil(source, destination),\n      50\n    );\n  };\n\n  solveMazeUtil = (source, destination) => {\n    let grid = document.querySelectorAll(\".cell\");\n    for (let i = 0; i < grid.length; i++) {\n      grid[i].classList.remove(\"solve\");\n    }\n\n    let currentDOM;\n    let next; // hold neighbour of current cell.\n\n    // execute for first time only.\n    if (flag) {\n      current = source;\n    }\n\n    // mark current cell as visited.\n    // get its non visited neighbour.\n    // push current cell in stack and set current cell to next cell.\n    // if no neighbour exist then backtrack to recently added cell to stack. \n    currentDOM = document.getElementById(current);\n    this.visited[this.arr.indexOf(current)] = true;\n    next = this.getActualNeighbour(current);\n    flag = false;\n    // for termination of setInterval in solveMaze.\n    if (next === destination) {\n      this.idInterval3 = setInterval(() => this.pathVisualisation(stack), 50);\n      clearInterval(this.idInterval2);\n      let end = document.getElementById(destination);\n      end.style.backgroundColor = \"red\";\n      this.setState({\n        resetBtn: true,\n        solveBtn: false,\n      });\n    }\n    if (next) {\n      stack.push(current);\n      current = next;\n    } else {\n      current = stack.pop(); // backtrack mechanism.\n    }\n    currentDOM.classList.add(\"solve\");\n  };\n\n  // Draw the resultant path. \n  pathVisualisation = (path) => {\n    if (path.length === 1) {\n      clearInterval(this.idInterval3);\n    } else {\n      let cell = path.pop();\n      let cellDOM = document.getElementById(cell);\n      cellDOM.classList.add(\"path\");\n    }\n  };\n\n  // reset the entire configuration.\n  resetMaze = () => {\n    this.visited = [];\n    this.cellArr = [];\n    this.arr = [];\n    let cells = document.querySelectorAll(\".cell\");\n    for (let i = 0; i < cells.length; i++) {\n      cells[i].style.borderTop = \"1px solid black\";\n      cells[i].style.borderRight = \"1px solid black\";\n      cells[i].style.borderBottom = \"1px solid black\";\n      cells[i].style.borderLeft = \"1px solid black\";\n      cells[i].classList.remove(\"path\");\n      cells[i].classList.remove(\"solve\");\n    }\n\n    let path = document.querySelectorAll(\"path\");\n    for (let i = 0; i < path.length; i++) {\n      path[i].style.backgroundColor = \"white\";\n      path[i].classList.remove(\"path\");\n    }\n\n    let destination = \"(\" + (this.n - 1) + \",\" + (this.n - 1) + \")\";\n    let end = document.getElementById(destination);\n    end.style.backgroundColor = \"white\";\n\n    this.createGrid();\n    this.visited = new Array(this.cellArr.length).fill(false);\n    flag = true;\n    this.setState({\n      generateBtn: true,\n      resetBtn: false,\n      solveBtn: false,\n    });\n  };\n\n  componentWillMount() {\n    this.createGrid();\n    this.visited = new Array(this.cellArr.length).fill(false);\n  }\n\n  render() {\n    return (\n      <div>\n        <div style={{ width: this.n * 50 }} className=\"matrix\">\n          {this.cellArr}\n        </div>\n        <div id=\"wrapper\">\n          <button\n            className=\"btn\"\n            onClick={this.generateMaze}\n            disabled={!this.state.generateBtn}\n          >\n            Generate\n          </button>\n          <button\n            className=\"btn\"\n            onClick={this.resetMaze}\n            disabled={!this.state.resetBtn}\n          >\n            Reset\n          </button>\n          <button\n            className=\"btn\"\n            onClick={this.solveMaze}\n            disabled={!this.state.solveBtn}\n          >\n            Solve\n          </button>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default Grid;\n","import React, { Component } from \"react\";\nimport \"./App.css\";\nimport Navbar from \"./Component/Navbar/Navbar\";\nimport Grid from \"./Component/Grid/Grid\";\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <Navbar />\n        <Grid size={8} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}